(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["/js/classes/comment"],{

/***/ "./node_modules/countable/Countable.js":
/*!*********************************************!*\
  !*** ./node_modules/countable/Countable.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Countable is a script to allow for live paragraph-, word- and character-
 * counting on an HTML element.
 *
 * @author   Sacha Schmid (<https://github.com/RadLikeWhoa>)
 * @version  3.0.1
 * @license  MIT
 * @see      <http://radlikewhoa.github.io/Countable/>
 */

/**
 * Note: For the purpose of this internal documentation, arguments of the type
 * {Nodes} are to be interpreted as either {NodeList} or {Element}.
 */

;(function (global) {

  /**
   * @private
   *
   * `liveElements` holds all elements that have the live-counting
   * functionality bound to them.
   */

  let liveElements = []
  const each = Array.prototype.forEach

  /**
   * `ucs2decode` function from the punycode.js library.
   *
   * Creates an array containing the decimal code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally, this
   * function will convert a pair of surrogate halves (each of which UCS-2
   * exposes as separate characters) into a single code point, matching
   * UTF-16.
   *
   * @see     <http://goo.gl/8M09r>
   * @see     <http://goo.gl/u4UUC>
   *
   * @param   {String}  string   The Unicode input string (UCS-2).
   *
   * @return  {Array}   The new array of code points.
   */

  function decode (string) {
    const output = []
  	let counter = 0
  	const length = string.length

  	while (counter < length) {
  		const value = string.charCodeAt(counter++)

  		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {

  			// It's a high surrogate, and there is a next character.

  			const extra = string.charCodeAt(counter++)

  			if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
  				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000)
  			} else {

  				// It's an unmatched surrogate; only append this code unit, in case the
  				// next code unit is the high surrogate of a surrogate pair.

  				output.push(value)
  				counter--
  			}
  		} else {
  			output.push(value)
  		}
  	}

  	return output
  }

  /**
   * `validateArguments` validates the arguments given to each function call.
   * Errors are logged to the console as warnings, but Countable fails
   * silently.
   *
   * @private
   *
   * @param   {Nodes|String}  targets   A (collection of) element(s) or a single
	 *                                    string to validate.
   *
   * @param   {Function}      callback  The callback function to validate.
   *
   * @return  {Boolean}       Returns whether all arguments are vaild.
   */

  function validateArguments (targets, callback) {
    const nodes = Object.prototype.toString.call(targets)
    const targetsValid = typeof targets === 'string' || ((nodes === '[object NodeList]' || nodes === '[object HTMLCollection]') || targets.nodeType === 1)
    const callbackValid = typeof callback === 'function'

    if (!targetsValid) console.error('Countable: Not a valid target')
    if (!callbackValid) console.error('Countable: Not a valid callback function')

    return targetsValid && callbackValid
  }

  /**
   * `count` trims an element's value, optionally strips HTML tags and counts
   * paragraphs, sentences, words, characters and characters plus spaces.
   *
   * @private
   *
   * @param   {Node|String}  target   The target for the count.
   *
   * @param   {Object}   	   options  The options to use for the counting.
   *
   * @return  {Object}       The object containing the number of paragraphs,
   *                         sentences, words, characters and characters
	 *                         plus spaces.
   */

  function count (target, options) {
    let original = '' + (typeof target === 'string' ? target : ('value' in target ? target.value : target.textContent))
    options = options || {}

    /**
     * The initial implementation to allow for HTML tags stripping was created
     * @craniumslows while the current one was created by @Rob--W.
     *
     * @see <http://goo.gl/Exmlr>
     * @see <http://goo.gl/gFQQh>
     */

    if (options.stripTags) original = original.replace(/<\/?[a-z][^>]*>/gi, '')

    if (options.ignore) {
        each.call(options.ignore, function (i) {
            original = original.replace(i, '')
        })
    }

    const trimmed = original.trim()

    /**
     * Most of the performance improvements are based on the works of @epmatsw.
     *
     * @see <http://goo.gl/SWOLB>
     */

    return {
      paragraphs: trimmed ? (trimmed.match(options.hardReturns ? /\n{2,}/g : /\n+/g) || []).length + 1 : 0,
      sentences: trimmed ? (trimmed.match(/[.?!…]+./g) || []).length + 1 : 0,
      words: trimmed ? (trimmed.replace(/['";:,.?¿\-!¡]+/g, '').match(/\S+/g) || []).length : 0,
      characters: trimmed ? decode(trimmed.replace(/\s/g, '')).length : 0,
      all: decode(original).length
    }
  }

  /**
   * This is the main object that will later be exposed to other scripts. It
   * holds all the public methods that can be used to enable the Countable
   * functionality.
   *
   * Some methods accept an optional options parameter. This includes the
   * following options.
   *
   * {Boolean}      hardReturns  Use two returns to seperate a paragraph
   *                             instead of one. (default: false)
   * {Boolean}      stripTags    Strip HTML tags before counting the values.
   *                             (default: false)
   * {Array<Char>}  ignore       A list of characters that should be removed
   *                             ignored when calculating the counters.
   *                             (default: )
   */

  const Countable = {

    /**
     * The `on` method binds the counting handler to all given elements. The
     * event is either `oninput` or `onkeydown`, based on the capabilities of
     * the browser.
     *
     * @param   {Nodes}     elements   All elements that should receive the
     *                                 Countable functionality.
     *
     * @param   {Function}  callback   The callback to fire whenever the
     *                                 element's value changes. The callback is
     *                                 called with the relevant element bound
     *                                 to `this` and the counted values as the
     *                                 single parameter.
     *
     * @param   {Object}    [options]  An object to modify Countable's
     *                                 behaviour.
     *
     * @return  {Object}    Returns the Countable object to allow for chaining.
     */

    on: function (elements, callback, options) {
      if (!validateArguments(elements, callback)) return

      if (!Array.isArray(elements)) {
          elements = [ elements ]
      }

      each.call(elements, function (e) {
          const handler = function () {
            callback.call(e, count(e, options))
          }

          liveElements.push({ element: e, handler: handler })

          handler()

          e.addEventListener('input', handler)
      })

      return this
    },

    /**
     * The `off` method removes the Countable functionality from all given
     * elements.
     *
     * @param   {Nodes}   elements  All elements whose Countable functionality
     *                              should be unbound.
     *
     * @return  {Object}  Returns the Countable object to allow for chaining.
     */

    off: function (elements) {
      if (!validateArguments(elements, function () {})) return

      if (!Array.isArray(elements)) {
          elements = [ elements ]
      }

      liveElements.filter(function (e) {
          return elements.indexOf(e.element) !== -1
      }).forEach(function (e) {
          e.element.removeEventListener('input', e.handler)
      })

      liveElements = liveElements.filter(function (e) {
          return elements.indexOf(e.element) === -1
      })

      return this
    },

    /**
     * The `count` method works mostly like the `live` method, but no events are
     * bound, the functionality is only executed once.
     *
     * @param   {Nodes|String}  targets   All elements that should be counted.
     *
     * @param   {Function}      callback   The callback to fire whenever the
     *                                     element's value changes. The callback
		 *                                     is called with the relevant element
		 *                                     bound to `this` and the counted values
		 *                                     as the single parameter.
     *
     * @param   {Object}        [options]  An object to modify Countable's
     *                                     behaviour.
     *
     * @return  {Object}    Returns the Countable object to allow for chaining.
     */

    count: function (targets, callback, options) {
      if (!validateArguments(targets, callback)) return

      if (!Array.isArray(targets)) {
          targets = [ targets ]
      }

      each.call(targets, function (e) {
          callback.call(e, count(e, options))
      })

      return this
    },

    /**
     * The `enabled` method checks if the live-counting functionality is bound
     * to an element.
     *
     * @param   {Node}     element  All elements that should be checked for the
     *                              Countable functionality.
     *
     * @return  {Boolean}  A boolean value representing whether Countable
     *                     functionality is bound to all given elements.
     */

    enabled: function (elements) {
      if (elements.length === undefined) {
        elements = [ elements ]
      }

      return liveElements.filter(function (e) {
          return elements.indexOf(e.element) !== -1
      }).length === elements.length
    }

  }

  /**
   * Expose Countable depending on the module system used across the
   * application. (Node / CommonJS, AMD, global)
   */

  if (true) {
    module.exports = Countable
  } else {}
}(this));


/***/ }),

/***/ "./resources/js/classes/comment.js":
/*!*****************************************!*\
  !*** ./resources/js/classes/comment.js ***!
  \*****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_Countable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Countable */ "./resources/js/utils/Countable.js");
/* harmony import */ var _utils_Validator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Validator */ "./resources/js/utils/Validator.js");



if (document.getElementById("comment-rating")) {
  Object(_utils_Countable__WEBPACK_IMPORTED_MODULE_0__["default"])('#comment-rating');
  _utils_Validator__WEBPACK_IMPORTED_MODULE_1__["default"].init('form#form-comment.rating', {
    comment: {
      required: true,
      rangelength: [5, 500]
    },
    rating: {
      required: true
    }
  }); /// Rating validation
  // Get elements

  var rating_input = document.getElementById("rating_input");
  var rating_number = document.getElementById("rating_number");
  var stars_filled = document.querySelectorAll(".star-filled");
  var stars_empty = document.querySelectorAll(".star-empty"); // Reset input

  rating_input.value = null; // Set click events to icons

  document.querySelectorAll(".star").forEach(function (star) {
    star.addEventListener("mouseenter", function () {
      format_rating(star.getAttribute("value"));
    });
    star.addEventListener("mouseleave", function () {
      format_rating();
    });
    star.addEventListener("click", function () {
      change_rating(star);
    });
  });
}

function format_rating() {
  var score = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  // Get score from input if is not set
  if (score == null) {
    score = rating_input.value;
  } // Set stars visibility


  stars_filled.forEach(function (star_filled) {
    star_filled.hidden = true;

    if (star_filled.getAttribute("value") <= score) {
      star_filled.hidden = false;
    }
  });
  stars_empty.forEach(function (star_empty) {
    star_empty.hidden = true;

    if (star_empty.getAttribute("value") > score) {
      star_empty.hidden = false;
    }
  }); // Change score text

  if (score != null && score != "") {
    rating_number.innerHTML = score;
  } else {
    rating_number.innerHTML = 0;
  }
}

function change_rating(star) {
  rating_input.value = star.getAttribute("value");
}

/***/ }),

/***/ "./resources/js/utils/Countable.js":
/*!*****************************************!*\
  !*** ./resources/js/utils/Countable.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var countable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! countable */ "./node_modules/countable/Countable.js");
/* harmony import */ var countable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(countable__WEBPACK_IMPORTED_MODULE_0__);


var init = function init(selector) {
  var $input = document.querySelector(selector);
  var limit = $input.dataset.limit;
  var label = $input.dataset.label;

  if (!limit || !label) {
    return;
  }

  var $counter = document.createElement('span');
  $counter.classList = 'badge badge-info mr-1';
  $counter.innerText = limit;
  var $label = document.createElement('span');
  $label.classList = 'small';
  $label.innerText = Lang.get(label);
  var $container = document.createElement('div');
  $container.classList = 'float-right';
  $container.appendChild($counter);
  $container.appendChild($label);
  $input.parentNode.appendChild($container, $input);
  label = label !== 'words' ? 'all' : label;
  countable__WEBPACK_IMPORTED_MODULE_0___default.a.on($input, function (counter) {
    var count = limit - counter[label];

    if (count <= 0) {
      $counter.innerText = '0';
      var text = $input.value;

      if (label === 'all') {
        text = text.substring(0, limit - 1);
      } else {
        while (count <= 0) {
          text = text.substring(0, text.lastIndexOf(' '));
          count++;
        }
      }

      $input.value = text;
    } else {
      $counter.innerText = count;
    }
  });
};

/* harmony default export */ __webpack_exports__["default"] = (init);

/***/ }),

/***/ "./resources/js/utils/Validator.js":
/*!*****************************************!*\
  !*** ./resources/js/utils/Validator.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*
    Validation.js

    Validation core

    Juan Carlos Espinosa Ceniceros
    EducarUno 2018
*/
// Extend validator
$.validator.addMethod('whitespaces', function (value, element) {
  return value.indexOf(' ') < 0 && value != '';
}, Lang.get('Blank spaces are not allowed'));
$.validator.addMethod('alpha_dash', function (value, element) {
  var regex = new RegExp('^[a-zA-Z0-9_-]+$');
  return value.match(regex);
}, Lang.get('Only letters, numbers, hyphen and underscore are allowed'));
$.validator.setDefaults({
  ignore: false,
  errorElement: 'span',
  errorClass: 'is-invalid small text-danger',
  validClass: 'is-valid'
});
var cfg = {
  errorPlacement: {
    "default": function _default(error, element) {
      if ($(element).parent().hasClass('input-group')) {
        $(element).parent().parent().append(error);
      } else if ($(element).parent().is('label')) {
        $(element).parent().parent().parent().append(error);
      } else {
        $(element).parent().append(error);
      }
    },
    twoLevel: function twoLevel(error, element) {
      $(element).parent().parent().parent().append(error);
    },
    file: function file(error, element) {
      if ($(element).attr('type') == 'file') {
        $(element).parent().parent().parent().parent().append(error);
      } else {
        if ($(element).parent().hasClass('input-group')) {
          $(element).parent().parent().append(error);
        } else {
          $(element).parent().append(error);
        }
      }
    }
  },
  highlight: {
    "default": function _default(element, errorClass, validClass) {
      $(element).removeClass(validClass).addClass(errorClass);
    },
    twoLevel: function twoLevel(element, errorClass, validClass) {
      if ($(element).parent().hasClass('input-group')) {
        $(element).parent().children().removeClass(validClass).removeClass(errorClass);
      }

      $(element).removeClass(validClass).addClass(errorClass);
    },
    file: function file(element, errorClass, validClass) {
      $(element).removeClass(validClass).addClass(errorClass);
    }
  },
  unhighlight: {
    "default": function _default(element, errorClass, validClass) {
      $(element).removeClass(errorClass).addClass(validClass);
      $(element).parent().children('span.' + errorClass).remove();
    },
    twoLevel: function twoLevel(element, errorClass, validClass) {
      if ($(element).parent().hasClass('input-group')) {
        $(element).parent().children().removeClass(errorClass).removeClass(validClass);
      }

      $(element).removeClass(errorClass).addClass(validClass);
      $(element).parent().parent().children('span.' + errorClass).remove();
    },
    file: function file(element, errorClass, validClass) {
      $(element).removeClass(errorClass).addClass(validClass);
      $(element).parent().children('span.' + errorClass).remove();
    }
  },
  invalidHandler: {
    "default": function _default(e, validator) {
      toastr['error'](Lang.get('There are errors in the validation of the fields'));
    },
    collapsePanel: function collapsePanel(e, validator) {
      for (var i = 0; i < validator.errorList.length; i++) {
        $(validator.errorList[i].element).closest('.panel-collapse.collapse').collapse('show');
      }
    }
  },
  submitHandler: {
    "default": function _default($form) {
      $('input[type="submit"]').attr('disabled', true);
      $form.submit();
    }
  }
};
/* harmony default export */ __webpack_exports__["default"] = ({
  init: function init(form_selector, rules) {
    var messages = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var $form = $(form_selector);
    var forms_count = $form.length;

    if (forms_count == 0) {
      console.warn('Form [' + form_selector + '] does not exist');
      return;
    }

    var config = {
      rules: rules,
      messages: messages,
      invalidHandler: cfg.invalidHandler[options['invalidHandler']] || cfg.invalidHandler['default'],
      errorPlacement: cfg.errorPlacement[options['errorPlacement']] || cfg.errorPlacement['default'],
      highlight: cfg.highlight[options['highlight']] || cfg.highlight['default'],
      unhighlight: cfg.unhighlight[options['unhighlight']] || cfg.unhighlight['default'],
      submitHandler: options['submitHandler'] || cfg.submitHandler['default']
    };

    try {
      var results = [];
      $form.each(function (i) {
        var r = $($form[i]).validate(config);
        results.push(r);
      });
      return forms_count > 1 ? results : results.shift();
    } catch (e) {
      console.error(e);
      return e;
    }
  }
});

/***/ }),

/***/ 66:
/*!***********************************************!*\
  !*** multi ./resources/js/classes/comment.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /home/futureed/html/huawei_code/resources/js/classes/comment.js */"./resources/js/classes/comment.js");


/***/ })

},[[66,"/js/manifest"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY291bnRhYmxlL0NvdW50YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY2xhc3Nlcy9jb21tZW50LmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy91dGlscy9Db3VudGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL3V0aWxzL1ZhbGlkYXRvci5qcyJdLCJuYW1lcyI6WyJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiaW5pdENvdW50YWJsZSIsIlZhbGlkYXRvciIsImluaXQiLCJjb21tZW50IiwicmVxdWlyZWQiLCJyYW5nZWxlbmd0aCIsInJhdGluZyIsInJhdGluZ19pbnB1dCIsInJhdGluZ19udW1iZXIiLCJzdGFyc19maWxsZWQiLCJxdWVyeVNlbGVjdG9yQWxsIiwic3RhcnNfZW1wdHkiLCJ2YWx1ZSIsImZvckVhY2giLCJzdGFyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImZvcm1hdF9yYXRpbmciLCJnZXRBdHRyaWJ1dGUiLCJjaGFuZ2VfcmF0aW5nIiwic2NvcmUiLCJzdGFyX2ZpbGxlZCIsImhpZGRlbiIsInN0YXJfZW1wdHkiLCJpbm5lckhUTUwiLCJzZWxlY3RvciIsIiRpbnB1dCIsInF1ZXJ5U2VsZWN0b3IiLCJsaW1pdCIsImRhdGFzZXQiLCJsYWJlbCIsIiRjb3VudGVyIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTGlzdCIsImlubmVyVGV4dCIsIiRsYWJlbCIsIkxhbmciLCJnZXQiLCIkY29udGFpbmVyIiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnROb2RlIiwiQ291bnRhYmxlIiwib24iLCJjb3VudGVyIiwiY291bnQiLCJ0ZXh0Iiwic3Vic3RyaW5nIiwibGFzdEluZGV4T2YiLCIkIiwidmFsaWRhdG9yIiwiYWRkTWV0aG9kIiwiZWxlbWVudCIsImluZGV4T2YiLCJyZWdleCIsIlJlZ0V4cCIsIm1hdGNoIiwic2V0RGVmYXVsdHMiLCJpZ25vcmUiLCJlcnJvckVsZW1lbnQiLCJlcnJvckNsYXNzIiwidmFsaWRDbGFzcyIsImNmZyIsImVycm9yUGxhY2VtZW50IiwiZXJyb3IiLCJwYXJlbnQiLCJoYXNDbGFzcyIsImFwcGVuZCIsImlzIiwidHdvTGV2ZWwiLCJmaWxlIiwiYXR0ciIsImhpZ2hsaWdodCIsInJlbW92ZUNsYXNzIiwiYWRkQ2xhc3MiLCJjaGlsZHJlbiIsInVuaGlnaGxpZ2h0IiwicmVtb3ZlIiwiaW52YWxpZEhhbmRsZXIiLCJlIiwidG9hc3RyIiwiY29sbGFwc2VQYW5lbCIsImkiLCJlcnJvckxpc3QiLCJsZW5ndGgiLCJjbG9zZXN0IiwiY29sbGFwc2UiLCJzdWJtaXRIYW5kbGVyIiwiJGZvcm0iLCJzdWJtaXQiLCJmb3JtX3NlbGVjdG9yIiwicnVsZXMiLCJtZXNzYWdlcyIsIm9wdGlvbnMiLCJmb3Jtc19jb3VudCIsImNvbnNvbGUiLCJ3YXJuIiwiY29uZmlnIiwicmVzdWx0cyIsImVhY2giLCJyIiwidmFsaWRhdGUiLCJwdXNoIiwic2hpZnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxNQUFNLGtDQUFrQyxTQUFTLEtBQUssUUFBUTtBQUNsRTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsTUFBTTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBLE1BQU07O0FBRU4scUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRSxHQUFHO0FBQ3hFO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFFBQVE7QUFDZDtBQUNBLE1BQU0sUUFBUTtBQUNkO0FBQ0EsTUFBTSxZQUFZO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLCtCQUErQjs7QUFFNUQ7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4Qjs7QUFFQTtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSztBQUN0QjtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sSUFBMkI7QUFDakM7QUFDQSxHQUFHLE1BQU0sRUFJTjtBQUNILENBQUM7Ozs7Ozs7Ozs7Ozs7QUN4VEQ7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQSxJQUFHQSxRQUFRLENBQUNDLGNBQVQsQ0FBd0IsZ0JBQXhCLENBQUgsRUFBOEM7QUFDNUNDLGtFQUFhLENBQUMsaUJBQUQsQ0FBYjtBQUVBQywwREFBUyxDQUFDQyxJQUFWLENBQWUsMEJBQWYsRUFBMkM7QUFDdkNDLFdBQU8sRUFBRTtBQUNQQyxjQUFRLEVBQUUsSUFESDtBQUVQQyxpQkFBVyxFQUFFLENBQUMsQ0FBRCxFQUFJLEdBQUo7QUFGTixLQUQ4QjtBQUt2Q0MsVUFBTSxFQUFFO0FBQ05GLGNBQVEsRUFBRTtBQURKO0FBTCtCLEdBQTNDLEVBSDRDLENBYTVDO0FBQ0E7O0FBQ0EsTUFBSUcsWUFBWSxHQUFHVCxRQUFRLENBQUNDLGNBQVQsQ0FBd0IsY0FBeEIsQ0FBbkI7QUFDQSxNQUFJUyxhQUFhLEdBQUdWLFFBQVEsQ0FBQ0MsY0FBVCxDQUF3QixlQUF4QixDQUFwQjtBQUNBLE1BQUlVLFlBQVksR0FBR1gsUUFBUSxDQUFDWSxnQkFBVCxDQUEwQixjQUExQixDQUFuQjtBQUNBLE1BQUlDLFdBQVcsR0FBR2IsUUFBUSxDQUFDWSxnQkFBVCxDQUEwQixhQUExQixDQUFsQixDQWxCNEMsQ0FtQjVDOztBQUNBSCxjQUFZLENBQUNLLEtBQWIsR0FBcUIsSUFBckIsQ0FwQjRDLENBcUI1Qzs7QUFDQWQsVUFBUSxDQUFDWSxnQkFBVCxDQUEwQixPQUExQixFQUFtQ0csT0FBbkMsQ0FBMkMsVUFBU0MsSUFBVCxFQUFlO0FBQ3hEQSxRQUFJLENBQUNDLGdCQUFMLENBQXNCLFlBQXRCLEVBQW9DLFlBQVc7QUFDN0NDLG1CQUFhLENBQUNGLElBQUksQ0FBQ0csWUFBTCxDQUFrQixPQUFsQixDQUFELENBQWI7QUFDRCxLQUZEO0FBR0FILFFBQUksQ0FBQ0MsZ0JBQUwsQ0FBc0IsWUFBdEIsRUFBb0MsWUFBVztBQUM3Q0MsbUJBQWE7QUFDZCxLQUZEO0FBR0FGLFFBQUksQ0FBQ0MsZ0JBQUwsQ0FBc0IsT0FBdEIsRUFBK0IsWUFBVztBQUN4Q0csbUJBQWEsQ0FBQ0osSUFBRCxDQUFiO0FBQ0QsS0FGRDtBQUdELEdBVkQ7QUFXRDs7QUFFRCxTQUFTRSxhQUFULEdBQW1DO0FBQUEsTUFBWkcsS0FBWSx1RUFBTixJQUFNOztBQUNqQztBQUNBLE1BQUdBLEtBQUssSUFBSSxJQUFaLEVBQWlCO0FBQ2ZBLFNBQUssR0FBR1osWUFBWSxDQUFDSyxLQUFyQjtBQUNELEdBSmdDLENBS2pDOzs7QUFDQUgsY0FBWSxDQUFDSSxPQUFiLENBQXFCLFVBQVNPLFdBQVQsRUFBc0I7QUFDekNBLGVBQVcsQ0FBQ0MsTUFBWixHQUFxQixJQUFyQjs7QUFDQSxRQUFHRCxXQUFXLENBQUNILFlBQVosQ0FBeUIsT0FBekIsS0FBcUNFLEtBQXhDLEVBQStDO0FBQzdDQyxpQkFBVyxDQUFDQyxNQUFaLEdBQXFCLEtBQXJCO0FBQ0Q7QUFDRixHQUxEO0FBTUFWLGFBQVcsQ0FBQ0UsT0FBWixDQUFvQixVQUFTUyxVQUFULEVBQXFCO0FBQ3ZDQSxjQUFVLENBQUNELE1BQVgsR0FBb0IsSUFBcEI7O0FBQ0EsUUFBR0MsVUFBVSxDQUFDTCxZQUFYLENBQXdCLE9BQXhCLElBQW1DRSxLQUF0QyxFQUE2QztBQUMzQ0csZ0JBQVUsQ0FBQ0QsTUFBWCxHQUFvQixLQUFwQjtBQUNEO0FBQ0YsR0FMRCxFQVppQyxDQWtCakM7O0FBQ0EsTUFBR0YsS0FBSyxJQUFJLElBQVQsSUFBaUJBLEtBQUssSUFBSSxFQUE3QixFQUFpQztBQUMvQlgsaUJBQWEsQ0FBQ2UsU0FBZCxHQUEwQkosS0FBMUI7QUFDRCxHQUZELE1BRUs7QUFDSFgsaUJBQWEsQ0FBQ2UsU0FBZCxHQUEwQixDQUExQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU0wsYUFBVCxDQUF1QkosSUFBdkIsRUFBNkI7QUFDM0JQLGNBQVksQ0FBQ0ssS0FBYixHQUFxQkUsSUFBSSxDQUFDRyxZQUFMLENBQWtCLE9BQWxCLENBQXJCO0FBQ0QsQzs7Ozs7Ozs7Ozs7O0FDbEVEO0FBQUE7QUFBQTtBQUFBOztBQUVBLElBQU1mLElBQUksR0FBRyxTQUFQQSxJQUFPLENBQUFzQixRQUFRLEVBQUk7QUFDckIsTUFBTUMsTUFBTSxHQUFHM0IsUUFBUSxDQUFDNEIsYUFBVCxDQUF1QkYsUUFBdkIsQ0FBZjtBQUNBLE1BQU1HLEtBQUssR0FBR0YsTUFBTSxDQUFDRyxPQUFQLENBQWVELEtBQTdCO0FBQ0EsTUFBSUUsS0FBSyxHQUFHSixNQUFNLENBQUNHLE9BQVAsQ0FBZUMsS0FBM0I7O0FBRUEsTUFBSSxDQUFDRixLQUFELElBQVUsQ0FBQ0UsS0FBZixFQUFzQjtBQUNsQjtBQUNIOztBQUVELE1BQUlDLFFBQVEsR0FBR2hDLFFBQVEsQ0FBQ2lDLGFBQVQsQ0FBdUIsTUFBdkIsQ0FBZjtBQUNBRCxVQUFRLENBQUNFLFNBQVQsR0FBcUIsdUJBQXJCO0FBQ0FGLFVBQVEsQ0FBQ0csU0FBVCxHQUFxQk4sS0FBckI7QUFFQSxNQUFJTyxNQUFNLEdBQUdwQyxRQUFRLENBQUNpQyxhQUFULENBQXVCLE1BQXZCLENBQWI7QUFDQUcsUUFBTSxDQUFDRixTQUFQLEdBQW1CLE9BQW5CO0FBQ0FFLFFBQU0sQ0FBQ0QsU0FBUCxHQUFtQkUsSUFBSSxDQUFDQyxHQUFMLENBQVNQLEtBQVQsQ0FBbkI7QUFFQSxNQUFJUSxVQUFVLEdBQUd2QyxRQUFRLENBQUNpQyxhQUFULENBQXVCLEtBQXZCLENBQWpCO0FBQ0FNLFlBQVUsQ0FBQ0wsU0FBWCxHQUF1QixhQUF2QjtBQUVBSyxZQUFVLENBQUNDLFdBQVgsQ0FBdUJSLFFBQXZCO0FBQ0FPLFlBQVUsQ0FBQ0MsV0FBWCxDQUF1QkosTUFBdkI7QUFFQVQsUUFBTSxDQUFDYyxVQUFQLENBQWtCRCxXQUFsQixDQUE4QkQsVUFBOUIsRUFBMENaLE1BQTFDO0FBRUFJLE9BQUssR0FBR0EsS0FBSyxLQUFLLE9BQVYsR0FBb0IsS0FBcEIsR0FBNEJBLEtBQXBDO0FBQ0FXLGtEQUFTLENBQUNDLEVBQVYsQ0FBYWhCLE1BQWIsRUFBcUIsVUFBQWlCLE9BQU8sRUFBSTtBQUM1QixRQUFJQyxLQUFLLEdBQUdoQixLQUFLLEdBQUdlLE9BQU8sQ0FBQ2IsS0FBRCxDQUEzQjs7QUFDQSxRQUFJYyxLQUFLLElBQUksQ0FBYixFQUFnQjtBQUNaYixjQUFRLENBQUNHLFNBQVQsR0FBcUIsR0FBckI7QUFDQSxVQUFJVyxJQUFJLEdBQUduQixNQUFNLENBQUNiLEtBQWxCOztBQUNBLFVBQUlpQixLQUFLLEtBQUssS0FBZCxFQUFxQjtBQUNqQmUsWUFBSSxHQUFHQSxJQUFJLENBQUNDLFNBQUwsQ0FBZSxDQUFmLEVBQWtCbEIsS0FBSyxHQUFHLENBQTFCLENBQVA7QUFDSCxPQUZELE1BRU87QUFDSCxlQUFPZ0IsS0FBSyxJQUFJLENBQWhCLEVBQW1CO0FBQ2ZDLGNBQUksR0FBR0EsSUFBSSxDQUFDQyxTQUFMLENBQWUsQ0FBZixFQUFrQkQsSUFBSSxDQUFDRSxXQUFMLENBQWlCLEdBQWpCLENBQWxCLENBQVA7QUFDQUgsZUFBSztBQUNSO0FBQ0o7O0FBQ0RsQixZQUFNLENBQUNiLEtBQVAsR0FBZWdDLElBQWY7QUFDSCxLQVpELE1BWU87QUFDSGQsY0FBUSxDQUFDRyxTQUFULEdBQXFCVSxLQUFyQjtBQUNIO0FBQ0osR0FqQkQ7QUFrQkgsQ0E1Q0Q7O0FBOENlekMsbUVBQWYsRTs7Ozs7Ozs7Ozs7O0FDaERBO0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTZDLENBQUMsQ0FBQ0MsU0FBRixDQUFZQyxTQUFaLENBQ0ksYUFESixFQUVJLFVBQUNyQyxLQUFELEVBQVFzQyxPQUFSLEVBQW9CO0FBQ2hCLFNBQU90QyxLQUFLLENBQUN1QyxPQUFOLENBQWMsR0FBZCxJQUFxQixDQUFyQixJQUEwQnZDLEtBQUssSUFBSSxFQUExQztBQUNILENBSkwsRUFLSXVCLElBQUksQ0FBQ0MsR0FBTCxDQUFTLDhCQUFULENBTEo7QUFRQVcsQ0FBQyxDQUFDQyxTQUFGLENBQVlDLFNBQVosQ0FDSSxZQURKLEVBRUksVUFBQ3JDLEtBQUQsRUFBUXNDLE9BQVIsRUFBb0I7QUFDaEIsTUFBSUUsS0FBSyxHQUFHLElBQUlDLE1BQUosQ0FBVyxrQkFBWCxDQUFaO0FBQ0EsU0FBT3pDLEtBQUssQ0FBQzBDLEtBQU4sQ0FBWUYsS0FBWixDQUFQO0FBQ0gsQ0FMTCxFQU1JakIsSUFBSSxDQUFDQyxHQUFMLENBQVMsMERBQVQsQ0FOSjtBQVNBVyxDQUFDLENBQUNDLFNBQUYsQ0FBWU8sV0FBWixDQUF3QjtBQUNwQkMsUUFBTSxFQUFFLEtBRFk7QUFFcEJDLGNBQVksRUFBRSxNQUZNO0FBR3BCQyxZQUFVLEVBQUUsOEJBSFE7QUFJcEJDLFlBQVUsRUFBRTtBQUpRLENBQXhCO0FBT0EsSUFBTUMsR0FBRyxHQUFHO0FBQ1JDLGdCQUFjLEVBQUU7QUFBQSxpQ0FDSkMsS0FESSxFQUNHWixPQURILEVBQ1k7QUFDcEIsVUFDSUgsQ0FBQyxDQUFDRyxPQUFELENBQUQsQ0FDS2EsTUFETCxHQUVLQyxRQUZMLENBRWMsYUFGZCxDQURKLEVBSUU7QUFDRWpCLFNBQUMsQ0FBQ0csT0FBRCxDQUFELENBQ0thLE1BREwsR0FFS0EsTUFGTCxHQUdLRSxNQUhMLENBR1lILEtBSFo7QUFJSCxPQVRELE1BU08sSUFDSGYsQ0FBQyxDQUFDRyxPQUFELENBQUQsQ0FDS2EsTUFETCxHQUVLRyxFQUZMLENBRVEsT0FGUixDQURHLEVBSUw7QUFDRW5CLFNBQUMsQ0FBQ0csT0FBRCxDQUFELENBQ0thLE1BREwsR0FFS0EsTUFGTCxHQUdLQSxNQUhMLEdBSUtFLE1BSkwsQ0FJWUgsS0FKWjtBQUtILE9BVk0sTUFVQTtBQUNIZixTQUFDLENBQUNHLE9BQUQsQ0FBRCxDQUNLYSxNQURMLEdBRUtFLE1BRkwsQ0FFWUgsS0FGWjtBQUdIO0FBQ0osS0ExQlc7QUEyQlpLLFlBM0JZLG9CQTJCSEwsS0EzQkcsRUEyQklaLE9BM0JKLEVBMkJhO0FBQ3JCSCxPQUFDLENBQUNHLE9BQUQsQ0FBRCxDQUNLYSxNQURMLEdBRUtBLE1BRkwsR0FHS0EsTUFITCxHQUlLRSxNQUpMLENBSVlILEtBSlo7QUFLSCxLQWpDVztBQWtDWk0sUUFsQ1ksZ0JBa0NQTixLQWxDTyxFQWtDQVosT0FsQ0EsRUFrQ1M7QUFDakIsVUFBSUgsQ0FBQyxDQUFDRyxPQUFELENBQUQsQ0FBV21CLElBQVgsQ0FBZ0IsTUFBaEIsS0FBMkIsTUFBL0IsRUFBdUM7QUFDbkN0QixTQUFDLENBQUNHLE9BQUQsQ0FBRCxDQUNLYSxNQURMLEdBRUtBLE1BRkwsR0FHS0EsTUFITCxHQUlLQSxNQUpMLEdBS0tFLE1BTEwsQ0FLWUgsS0FMWjtBQU1ILE9BUEQsTUFPTztBQUNILFlBQ0lmLENBQUMsQ0FBQ0csT0FBRCxDQUFELENBQ0thLE1BREwsR0FFS0MsUUFGTCxDQUVjLGFBRmQsQ0FESixFQUlFO0FBQ0VqQixXQUFDLENBQUNHLE9BQUQsQ0FBRCxDQUNLYSxNQURMLEdBRUtBLE1BRkwsR0FHS0UsTUFITCxDQUdZSCxLQUhaO0FBSUgsU0FURCxNQVNPO0FBQ0hmLFdBQUMsQ0FBQ0csT0FBRCxDQUFELENBQ0thLE1BREwsR0FFS0UsTUFGTCxDQUVZSCxLQUZaO0FBR0g7QUFDSjtBQUNKO0FBMURXLEdBRFI7QUE2RFJRLFdBQVMsRUFBRTtBQUFBLGlDQUNDcEIsT0FERCxFQUNVUSxVQURWLEVBQ3NCQyxVQUR0QixFQUNrQztBQUNyQ1osT0FBQyxDQUFDRyxPQUFELENBQUQsQ0FDS3FCLFdBREwsQ0FDaUJaLFVBRGpCLEVBRUthLFFBRkwsQ0FFY2QsVUFGZDtBQUdILEtBTE07QUFNUFMsWUFOTyxvQkFNRWpCLE9BTkYsRUFNV1EsVUFOWCxFQU11QkMsVUFOdkIsRUFNbUM7QUFDdEMsVUFDSVosQ0FBQyxDQUFDRyxPQUFELENBQUQsQ0FDS2EsTUFETCxHQUVLQyxRQUZMLENBRWMsYUFGZCxDQURKLEVBSUU7QUFDRWpCLFNBQUMsQ0FBQ0csT0FBRCxDQUFELENBQ0thLE1BREwsR0FFS1UsUUFGTCxHQUdLRixXQUhMLENBR2lCWixVQUhqQixFQUlLWSxXQUpMLENBSWlCYixVQUpqQjtBQUtIOztBQUNEWCxPQUFDLENBQUNHLE9BQUQsQ0FBRCxDQUNLcUIsV0FETCxDQUNpQlosVUFEakIsRUFFS2EsUUFGTCxDQUVjZCxVQUZkO0FBR0gsS0FyQk07QUFzQlBVLFFBdEJPLGdCQXNCRmxCLE9BdEJFLEVBc0JPUSxVQXRCUCxFQXNCbUJDLFVBdEJuQixFQXNCK0I7QUFDbENaLE9BQUMsQ0FBQ0csT0FBRCxDQUFELENBQ0txQixXQURMLENBQ2lCWixVQURqQixFQUVLYSxRQUZMLENBRWNkLFVBRmQ7QUFHSDtBQTFCTSxHQTdESDtBQXlGUmdCLGFBQVcsRUFBRTtBQUFBLGlDQUNEeEIsT0FEQyxFQUNRUSxVQURSLEVBQ29CQyxVQURwQixFQUNnQztBQUNyQ1osT0FBQyxDQUFDRyxPQUFELENBQUQsQ0FDS3FCLFdBREwsQ0FDaUJiLFVBRGpCLEVBRUtjLFFBRkwsQ0FFY2IsVUFGZDtBQUdBWixPQUFDLENBQUNHLE9BQUQsQ0FBRCxDQUNLYSxNQURMLEdBRUtVLFFBRkwsQ0FFYyxVQUFVZixVQUZ4QixFQUdLaUIsTUFITDtBQUlILEtBVFE7QUFVVFIsWUFWUyxvQkFVQWpCLE9BVkEsRUFVU1EsVUFWVCxFQVVxQkMsVUFWckIsRUFVaUM7QUFDdEMsVUFDSVosQ0FBQyxDQUFDRyxPQUFELENBQUQsQ0FDS2EsTUFETCxHQUVLQyxRQUZMLENBRWMsYUFGZCxDQURKLEVBSUU7QUFDRWpCLFNBQUMsQ0FBQ0csT0FBRCxDQUFELENBQ0thLE1BREwsR0FFS1UsUUFGTCxHQUdLRixXQUhMLENBR2lCYixVQUhqQixFQUlLYSxXQUpMLENBSWlCWixVQUpqQjtBQUtIOztBQUNEWixPQUFDLENBQUNHLE9BQUQsQ0FBRCxDQUNLcUIsV0FETCxDQUNpQmIsVUFEakIsRUFFS2MsUUFGTCxDQUVjYixVQUZkO0FBR0FaLE9BQUMsQ0FBQ0csT0FBRCxDQUFELENBQ0thLE1BREwsR0FFS0EsTUFGTCxHQUdLVSxRQUhMLENBR2MsVUFBVWYsVUFIeEIsRUFJS2lCLE1BSkw7QUFLSCxLQTlCUTtBQStCVFAsUUEvQlMsZ0JBK0JKbEIsT0EvQkksRUErQktRLFVBL0JMLEVBK0JpQkMsVUEvQmpCLEVBK0I2QjtBQUNsQ1osT0FBQyxDQUFDRyxPQUFELENBQUQsQ0FDS3FCLFdBREwsQ0FDaUJiLFVBRGpCLEVBRUtjLFFBRkwsQ0FFY2IsVUFGZDtBQUdBWixPQUFDLENBQUNHLE9BQUQsQ0FBRCxDQUNLYSxNQURMLEdBRUtVLFFBRkwsQ0FFYyxVQUFVZixVQUZ4QixFQUdLaUIsTUFITDtBQUlIO0FBdkNRLEdBekZMO0FBa0lSQyxnQkFBYyxFQUFFO0FBQUEsaUNBQ0pDLENBREksRUFDRDdCLFNBREMsRUFDVTtBQUNsQjhCLFlBQU0sQ0FBQyxPQUFELENBQU4sQ0FDSTNDLElBQUksQ0FBQ0MsR0FBTCxDQUFTLGtEQUFULENBREo7QUFHSCxLQUxXO0FBTVoyQyxpQkFOWSx5QkFNRUYsQ0FORixFQU1LN0IsU0FOTCxFQU1nQjtBQUN4QixXQUFLLElBQUlnQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHaEMsU0FBUyxDQUFDaUMsU0FBVixDQUFvQkMsTUFBeEMsRUFBZ0RGLENBQUMsRUFBakQsRUFBcUQ7QUFDakRqQyxTQUFDLENBQUNDLFNBQVMsQ0FBQ2lDLFNBQVYsQ0FBb0JELENBQXBCLEVBQXVCOUIsT0FBeEIsQ0FBRCxDQUNLaUMsT0FETCxDQUNhLDBCQURiLEVBRUtDLFFBRkwsQ0FFYyxNQUZkO0FBR0g7QUFDSjtBQVpXLEdBbElSO0FBZ0pSQyxlQUFhLEVBQUU7QUFBQSxpQ0FDSEMsS0FERyxFQUNJO0FBQ1h2QyxPQUFDLENBQUMsc0JBQUQsQ0FBRCxDQUEwQnNCLElBQTFCLENBQStCLFVBQS9CLEVBQTJDLElBQTNDO0FBQ0FpQixXQUFLLENBQUNDLE1BQU47QUFDSDtBQUpVO0FBaEpQLENBQVo7QUF3SmU7QUFDWHJGLE1BRFcsZ0JBQ05zRixhQURNLEVBQ1NDLEtBRFQsRUFDNkM7QUFBQSxRQUE3QkMsUUFBNkIsdUVBQWxCLEVBQWtCO0FBQUEsUUFBZEMsT0FBYyx1RUFBSixFQUFJO0FBQ3BELFFBQU1MLEtBQUssR0FBR3ZDLENBQUMsQ0FBQ3lDLGFBQUQsQ0FBZjtBQUNBLFFBQU1JLFdBQVcsR0FBR04sS0FBSyxDQUFDSixNQUExQjs7QUFDQSxRQUFJVSxXQUFXLElBQUksQ0FBbkIsRUFBc0I7QUFDbEJDLGFBQU8sQ0FBQ0MsSUFBUixDQUFhLFdBQVdOLGFBQVgsR0FBMkIsa0JBQXhDO0FBQ0E7QUFDSDs7QUFFRCxRQUFNTyxNQUFNLEdBQUc7QUFDWE4sV0FBSyxFQUFFQSxLQURJO0FBRVhDLGNBQVEsRUFBRUEsUUFGQztBQUdYZCxvQkFBYyxFQUNWaEIsR0FBRyxDQUFDZ0IsY0FBSixDQUFtQmUsT0FBTyxDQUFDLGdCQUFELENBQTFCLEtBQ0EvQixHQUFHLENBQUNnQixjQUFKLENBQW1CLFNBQW5CLENBTE87QUFNWGYsb0JBQWMsRUFDVkQsR0FBRyxDQUFDQyxjQUFKLENBQW1COEIsT0FBTyxDQUFDLGdCQUFELENBQTFCLEtBQ0EvQixHQUFHLENBQUNDLGNBQUosQ0FBbUIsU0FBbkIsQ0FSTztBQVNYUyxlQUFTLEVBQ0xWLEdBQUcsQ0FBQ1UsU0FBSixDQUFjcUIsT0FBTyxDQUFDLFdBQUQsQ0FBckIsS0FBdUMvQixHQUFHLENBQUNVLFNBQUosQ0FBYyxTQUFkLENBVmhDO0FBV1hJLGlCQUFXLEVBQ1BkLEdBQUcsQ0FBQ2MsV0FBSixDQUFnQmlCLE9BQU8sQ0FBQyxhQUFELENBQXZCLEtBQ0EvQixHQUFHLENBQUNjLFdBQUosQ0FBZ0IsU0FBaEIsQ0FiTztBQWNYVyxtQkFBYSxFQUNUTSxPQUFPLENBQUMsZUFBRCxDQUFQLElBQTRCL0IsR0FBRyxDQUFDeUIsYUFBSixDQUFrQixTQUFsQjtBQWZyQixLQUFmOztBQWtCQSxRQUFJO0FBQ0EsVUFBTVcsT0FBTyxHQUFHLEVBQWhCO0FBQ0FWLFdBQUssQ0FBQ1csSUFBTixDQUFXLFVBQUFqQixDQUFDLEVBQUk7QUFDWixZQUFJa0IsQ0FBQyxHQUFHbkQsQ0FBQyxDQUFDdUMsS0FBSyxDQUFDTixDQUFELENBQU4sQ0FBRCxDQUFZbUIsUUFBWixDQUFxQkosTUFBckIsQ0FBUjtBQUNBQyxlQUFPLENBQUNJLElBQVIsQ0FBYUYsQ0FBYjtBQUNILE9BSEQ7QUFJQSxhQUFPTixXQUFXLEdBQUcsQ0FBZCxHQUFrQkksT0FBbEIsR0FBNEJBLE9BQU8sQ0FBQ0ssS0FBUixFQUFuQztBQUNILEtBUEQsQ0FPRSxPQUFPeEIsQ0FBUCxFQUFVO0FBQ1JnQixhQUFPLENBQUMvQixLQUFSLENBQWNlLENBQWQ7QUFDQSxhQUFPQSxDQUFQO0FBQ0g7QUFDSjtBQXRDVSxDQUFmLEUiLCJmaWxlIjoiL2pzL2NsYXNzZXMvY29tbWVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ291bnRhYmxlIGlzIGEgc2NyaXB0IHRvIGFsbG93IGZvciBsaXZlIHBhcmFncmFwaC0sIHdvcmQtIGFuZCBjaGFyYWN0ZXItXG4gKiBjb3VudGluZyBvbiBhbiBIVE1MIGVsZW1lbnQuXG4gKlxuICogQGF1dGhvciAgIFNhY2hhIFNjaG1pZCAoPGh0dHBzOi8vZ2l0aHViLmNvbS9SYWRMaWtlV2hvYT4pXG4gKiBAdmVyc2lvbiAgMy4wLjFcbiAqIEBsaWNlbnNlICBNSVRcbiAqIEBzZWUgICAgICA8aHR0cDovL3JhZGxpa2V3aG9hLmdpdGh1Yi5pby9Db3VudGFibGUvPlxuICovXG5cbi8qKlxuICogTm90ZTogRm9yIHRoZSBwdXJwb3NlIG9mIHRoaXMgaW50ZXJuYWwgZG9jdW1lbnRhdGlvbiwgYXJndW1lbnRzIG9mIHRoZSB0eXBlXG4gKiB7Tm9kZXN9IGFyZSB0byBiZSBpbnRlcnByZXRlZCBhcyBlaXRoZXIge05vZGVMaXN0fSBvciB7RWxlbWVudH0uXG4gKi9cblxuOyhmdW5jdGlvbiAoZ2xvYmFsKSB7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIGBsaXZlRWxlbWVudHNgIGhvbGRzIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIGxpdmUtY291bnRpbmdcbiAgICogZnVuY3Rpb25hbGl0eSBib3VuZCB0byB0aGVtLlxuICAgKi9cblxuICBsZXQgbGl2ZUVsZW1lbnRzID0gW11cbiAgY29uc3QgZWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoXG5cbiAgLyoqXG4gICAqIGB1Y3MyZGVjb2RlYCBmdW5jdGlvbiBmcm9tIHRoZSBwdW55Y29kZS5qcyBsaWJyYXJ5LlxuICAgKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRlY2ltYWwgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG4gICAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSwgdGhpc1xuICAgKiBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2ggVUNTLTJcbiAgICogZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsIG1hdGNoaW5nXG4gICAqIFVURi0xNi5cbiAgICpcbiAgICogQHNlZSAgICAgPGh0dHA6Ly9nb28uZ2wvOE0wOXI+XG4gICAqIEBzZWUgICAgIDxodHRwOi8vZ29vLmdsL3U0VVVDPlxuICAgKlxuICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgc3RyaW5nICAgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gICAqXG4gICAqIEByZXR1cm4gIHtBcnJheX0gICBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuICAgKi9cblxuICBmdW5jdGlvbiBkZWNvZGUgKHN0cmluZykge1xuICAgIGNvbnN0IG91dHB1dCA9IFtdXG4gIFx0bGV0IGNvdW50ZXIgPSAwXG4gIFx0Y29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuXG4gIFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgXHRcdGNvbnN0IHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKVxuXG4gIFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cbiAgXHRcdFx0Ly8gSXQncyBhIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3Rlci5cblxuICBcdFx0XHRjb25zdCBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKylcblxuICBcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gTG93IHN1cnJvZ2F0ZS5cbiAgXHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApXG4gIFx0XHRcdH0gZWxzZSB7XG5cbiAgXHRcdFx0XHQvLyBJdCdzIGFuIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZVxuICBcdFx0XHRcdC8vIG5leHQgY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuXG4gIFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpXG4gIFx0XHRcdFx0Y291bnRlci0tXG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBvdXRwdXRcbiAgfVxuXG4gIC8qKlxuICAgKiBgdmFsaWRhdGVBcmd1bWVudHNgIHZhbGlkYXRlcyB0aGUgYXJndW1lbnRzIGdpdmVuIHRvIGVhY2ggZnVuY3Rpb24gY2FsbC5cbiAgICogRXJyb3JzIGFyZSBsb2dnZWQgdG8gdGhlIGNvbnNvbGUgYXMgd2FybmluZ3MsIGJ1dCBDb3VudGFibGUgZmFpbHNcbiAgICogc2lsZW50bHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSAgIHtOb2Rlc3xTdHJpbmd9ICB0YXJnZXRzICAgQSAoY29sbGVjdGlvbiBvZikgZWxlbWVudChzKSBvciBhIHNpbmdsZVxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyB0byB2YWxpZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSAgICAgIGNhbGxiYWNrICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gdmFsaWRhdGUuXG4gICAqXG4gICAqIEByZXR1cm4gIHtCb29sZWFufSAgICAgICBSZXR1cm5zIHdoZXRoZXIgYWxsIGFyZ3VtZW50cyBhcmUgdmFpbGQuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlQXJndW1lbnRzICh0YXJnZXRzLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG5vZGVzID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhcmdldHMpXG4gICAgY29uc3QgdGFyZ2V0c1ZhbGlkID0gdHlwZW9mIHRhcmdldHMgPT09ICdzdHJpbmcnIHx8ICgobm9kZXMgPT09ICdbb2JqZWN0IE5vZGVMaXN0XScgfHwgbm9kZXMgPT09ICdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXScpIHx8IHRhcmdldHMubm9kZVR5cGUgPT09IDEpXG4gICAgY29uc3QgY2FsbGJhY2tWYWxpZCA9IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJ1xuXG4gICAgaWYgKCF0YXJnZXRzVmFsaWQpIGNvbnNvbGUuZXJyb3IoJ0NvdW50YWJsZTogTm90IGEgdmFsaWQgdGFyZ2V0JylcbiAgICBpZiAoIWNhbGxiYWNrVmFsaWQpIGNvbnNvbGUuZXJyb3IoJ0NvdW50YWJsZTogTm90IGEgdmFsaWQgY2FsbGJhY2sgZnVuY3Rpb24nKVxuXG4gICAgcmV0dXJuIHRhcmdldHNWYWxpZCAmJiBjYWxsYmFja1ZhbGlkXG4gIH1cblxuICAvKipcbiAgICogYGNvdW50YCB0cmltcyBhbiBlbGVtZW50J3MgdmFsdWUsIG9wdGlvbmFsbHkgc3RyaXBzIEhUTUwgdGFncyBhbmQgY291bnRzXG4gICAqIHBhcmFncmFwaHMsIHNlbnRlbmNlcywgd29yZHMsIGNoYXJhY3RlcnMgYW5kIGNoYXJhY3RlcnMgcGx1cyBzcGFjZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSAgIHtOb2RlfFN0cmluZ30gIHRhcmdldCAgIFRoZSB0YXJnZXQgZm9yIHRoZSBjb3VudC5cbiAgICpcbiAgICogQHBhcmFtICAge09iamVjdH0gICBcdCAgIG9wdGlvbnMgIFRoZSBvcHRpb25zIHRvIHVzZSBmb3IgdGhlIGNvdW50aW5nLlxuICAgKlxuICAgKiBAcmV0dXJuICB7T2JqZWN0fSAgICAgICBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG51bWJlciBvZiBwYXJhZ3JhcGhzLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBzZW50ZW5jZXMsIHdvcmRzLCBjaGFyYWN0ZXJzIGFuZCBjaGFyYWN0ZXJzXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgIHBsdXMgc3BhY2VzLlxuICAgKi9cblxuICBmdW5jdGlvbiBjb3VudCAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgbGV0IG9yaWdpbmFsID0gJycgKyAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyB0YXJnZXQgOiAoJ3ZhbHVlJyBpbiB0YXJnZXQgPyB0YXJnZXQudmFsdWUgOiB0YXJnZXQudGV4dENvbnRlbnQpKVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5pdGlhbCBpbXBsZW1lbnRhdGlvbiB0byBhbGxvdyBmb3IgSFRNTCB0YWdzIHN0cmlwcGluZyB3YXMgY3JlYXRlZFxuICAgICAqIEBjcmFuaXVtc2xvd3Mgd2hpbGUgdGhlIGN1cnJlbnQgb25lIHdhcyBjcmVhdGVkIGJ5IEBSb2ItLVcuXG4gICAgICpcbiAgICAgKiBAc2VlIDxodHRwOi8vZ29vLmdsL0V4bWxyPlxuICAgICAqIEBzZWUgPGh0dHA6Ly9nb28uZ2wvZ0ZRUWg+XG4gICAgICovXG5cbiAgICBpZiAob3B0aW9ucy5zdHJpcFRhZ3MpIG9yaWdpbmFsID0gb3JpZ2luYWwucmVwbGFjZSgvPFxcLz9bYS16XVtePl0qPi9naSwgJycpXG5cbiAgICBpZiAob3B0aW9ucy5pZ25vcmUpIHtcbiAgICAgICAgZWFjaC5jYWxsKG9wdGlvbnMuaWdub3JlLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgb3JpZ2luYWwgPSBvcmlnaW5hbC5yZXBsYWNlKGksICcnKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IHRyaW1tZWQgPSBvcmlnaW5hbC50cmltKClcblxuICAgIC8qKlxuICAgICAqIE1vc3Qgb2YgdGhlIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50cyBhcmUgYmFzZWQgb24gdGhlIHdvcmtzIG9mIEBlcG1hdHN3LlxuICAgICAqXG4gICAgICogQHNlZSA8aHR0cDovL2dvby5nbC9TV09MQj5cbiAgICAgKi9cblxuICAgIHJldHVybiB7XG4gICAgICBwYXJhZ3JhcGhzOiB0cmltbWVkID8gKHRyaW1tZWQubWF0Y2gob3B0aW9ucy5oYXJkUmV0dXJucyA/IC9cXG57Mix9L2cgOiAvXFxuKy9nKSB8fCBbXSkubGVuZ3RoICsgMSA6IDAsXG4gICAgICBzZW50ZW5jZXM6IHRyaW1tZWQgPyAodHJpbW1lZC5tYXRjaCgvWy4/IeKApl0rLi9nKSB8fCBbXSkubGVuZ3RoICsgMSA6IDAsXG4gICAgICB3b3JkczogdHJpbW1lZCA/ICh0cmltbWVkLnJlcGxhY2UoL1snXCI7OiwuP8K/XFwtIcKhXSsvZywgJycpLm1hdGNoKC9cXFMrL2cpIHx8IFtdKS5sZW5ndGggOiAwLFxuICAgICAgY2hhcmFjdGVyczogdHJpbW1lZCA/IGRlY29kZSh0cmltbWVkLnJlcGxhY2UoL1xccy9nLCAnJykpLmxlbmd0aCA6IDAsXG4gICAgICBhbGw6IGRlY29kZShvcmlnaW5hbCkubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIG1haW4gb2JqZWN0IHRoYXQgd2lsbCBsYXRlciBiZSBleHBvc2VkIHRvIG90aGVyIHNjcmlwdHMuIEl0XG4gICAqIGhvbGRzIGFsbCB0aGUgcHVibGljIG1ldGhvZHMgdGhhdCBjYW4gYmUgdXNlZCB0byBlbmFibGUgdGhlIENvdW50YWJsZVxuICAgKiBmdW5jdGlvbmFsaXR5LlxuICAgKlxuICAgKiBTb21lIG1ldGhvZHMgYWNjZXB0IGFuIG9wdGlvbmFsIG9wdGlvbnMgcGFyYW1ldGVyLiBUaGlzIGluY2x1ZGVzIHRoZVxuICAgKiBmb2xsb3dpbmcgb3B0aW9ucy5cbiAgICpcbiAgICoge0Jvb2xlYW59ICAgICAgaGFyZFJldHVybnMgIFVzZSB0d28gcmV0dXJucyB0byBzZXBlcmF0ZSBhIHBhcmFncmFwaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGVhZCBvZiBvbmUuIChkZWZhdWx0OiBmYWxzZSlcbiAgICoge0Jvb2xlYW59ICAgICAgc3RyaXBUYWdzICAgIFN0cmlwIEhUTUwgdGFncyBiZWZvcmUgY291bnRpbmcgdGhlIHZhbHVlcy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkZWZhdWx0OiBmYWxzZSlcbiAgICoge0FycmF5PENoYXI+fSAgaWdub3JlICAgICAgIEEgbGlzdCBvZiBjaGFyYWN0ZXJzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgY291bnRlcnMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGVmYXVsdDogKVxuICAgKi9cblxuICBjb25zdCBDb3VudGFibGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYG9uYCBtZXRob2QgYmluZHMgdGhlIGNvdW50aW5nIGhhbmRsZXIgdG8gYWxsIGdpdmVuIGVsZW1lbnRzLiBUaGVcbiAgICAgKiBldmVudCBpcyBlaXRoZXIgYG9uaW5wdXRgIG9yIGBvbmtleWRvd25gLCBiYXNlZCBvbiB0aGUgY2FwYWJpbGl0aWVzIG9mXG4gICAgICogdGhlIGJyb3dzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICB7Tm9kZXN9ICAgICBlbGVtZW50cyAgIEFsbCBlbGVtZW50cyB0aGF0IHNob3VsZCByZWNlaXZlIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ291bnRhYmxlIGZ1bmN0aW9uYWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICB7RnVuY3Rpb259ICBjYWxsYmFjayAgIFRoZSBjYWxsYmFjayB0byBmaXJlIHdoZW5ldmVyIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCdzIHZhbHVlIGNoYW5nZXMuIFRoZSBjYWxsYmFjayBpc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVkIHdpdGggdGhlIHJlbGV2YW50IGVsZW1lbnQgYm91bmRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGB0aGlzYCBhbmQgdGhlIGNvdW50ZWQgdmFsdWVzIGFzIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luZ2xlIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIHtPYmplY3R9ICAgIFtvcHRpb25zXSAgQW4gb2JqZWN0IHRvIG1vZGlmeSBDb3VudGFibGUnc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVoYXZpb3VyLlxuICAgICAqXG4gICAgICogQHJldHVybiAge09iamVjdH0gICAgUmV0dXJucyB0aGUgQ291bnRhYmxlIG9iamVjdCB0byBhbGxvdyBmb3IgY2hhaW5pbmcuXG4gICAgICovXG5cbiAgICBvbjogZnVuY3Rpb24gKGVsZW1lbnRzLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgaWYgKCF2YWxpZGF0ZUFyZ3VtZW50cyhlbGVtZW50cywgY2FsbGJhY2spKSByZXR1cm5cblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGVsZW1lbnRzKSkge1xuICAgICAgICAgIGVsZW1lbnRzID0gWyBlbGVtZW50cyBdXG4gICAgICB9XG5cbiAgICAgIGVhY2guY2FsbChlbGVtZW50cywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBjb25zdCBoYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChlLCBjb3VudChlLCBvcHRpb25zKSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXZlRWxlbWVudHMucHVzaCh7IGVsZW1lbnQ6IGUsIGhhbmRsZXI6IGhhbmRsZXIgfSlcblxuICAgICAgICAgIGhhbmRsZXIoKVxuXG4gICAgICAgICAgZS5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGhhbmRsZXIpXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYG9mZmAgbWV0aG9kIHJlbW92ZXMgdGhlIENvdW50YWJsZSBmdW5jdGlvbmFsaXR5IGZyb20gYWxsIGdpdmVuXG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICB7Tm9kZXN9ICAgZWxlbWVudHMgIEFsbCBlbGVtZW50cyB3aG9zZSBDb3VudGFibGUgZnVuY3Rpb25hbGl0eVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIGJlIHVuYm91bmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuICB7T2JqZWN0fSAgUmV0dXJucyB0aGUgQ291bnRhYmxlIG9iamVjdCB0byBhbGxvdyBmb3IgY2hhaW5pbmcuXG4gICAgICovXG5cbiAgICBvZmY6IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgaWYgKCF2YWxpZGF0ZUFyZ3VtZW50cyhlbGVtZW50cywgZnVuY3Rpb24gKCkge30pKSByZXR1cm5cblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGVsZW1lbnRzKSkge1xuICAgICAgICAgIGVsZW1lbnRzID0gWyBlbGVtZW50cyBdXG4gICAgICB9XG5cbiAgICAgIGxpdmVFbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudHMuaW5kZXhPZihlLmVsZW1lbnQpICE9PSAtMVxuICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIGUuaGFuZGxlcilcbiAgICAgIH0pXG5cbiAgICAgIGxpdmVFbGVtZW50cyA9IGxpdmVFbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudHMuaW5kZXhPZihlLmVsZW1lbnQpID09PSAtMVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGBjb3VudGAgbWV0aG9kIHdvcmtzIG1vc3RseSBsaWtlIHRoZSBgbGl2ZWAgbWV0aG9kLCBidXQgbm8gZXZlbnRzIGFyZVxuICAgICAqIGJvdW5kLCB0aGUgZnVuY3Rpb25hbGl0eSBpcyBvbmx5IGV4ZWN1dGVkIG9uY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICB7Tm9kZXN8U3RyaW5nfSAgdGFyZ2V0cyAgIEFsbCBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSBjb3VudGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICAge0Z1bmN0aW9ufSAgICAgIGNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIHRvIGZpcmUgd2hlbmV2ZXIgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCdzIHZhbHVlIGNoYW5nZXMuIFRoZSBjYWxsYmFja1xuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGNhbGxlZCB3aXRoIHRoZSByZWxldmFudCBlbGVtZW50XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmQgdG8gYHRoaXNgIGFuZCB0aGUgY291bnRlZCB2YWx1ZXNcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyB0aGUgc2luZ2xlIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIHtPYmplY3R9ICAgICAgICBbb3B0aW9uc10gIEFuIG9iamVjdCB0byBtb2RpZnkgQ291bnRhYmxlJ3NcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWhhdmlvdXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuICB7T2JqZWN0fSAgICBSZXR1cm5zIHRoZSBDb3VudGFibGUgb2JqZWN0IHRvIGFsbG93IGZvciBjaGFpbmluZy5cbiAgICAgKi9cblxuICAgIGNvdW50OiBmdW5jdGlvbiAodGFyZ2V0cywgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIGlmICghdmFsaWRhdGVBcmd1bWVudHModGFyZ2V0cywgY2FsbGJhY2spKSByZXR1cm5cblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhcmdldHMpKSB7XG4gICAgICAgICAgdGFyZ2V0cyA9IFsgdGFyZ2V0cyBdXG4gICAgICB9XG5cbiAgICAgIGVhY2guY2FsbCh0YXJnZXRzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwoZSwgY291bnQoZSwgb3B0aW9ucykpXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYGVuYWJsZWRgIG1ldGhvZCBjaGVja3MgaWYgdGhlIGxpdmUtY291bnRpbmcgZnVuY3Rpb25hbGl0eSBpcyBib3VuZFxuICAgICAqIHRvIGFuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICB7Tm9kZX0gICAgIGVsZW1lbnQgIEFsbCBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSBjaGVja2VkIGZvciB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvdW50YWJsZSBmdW5jdGlvbmFsaXR5LlxuICAgICAqXG4gICAgICogQHJldHVybiAge0Jvb2xlYW59ICBBIGJvb2xlYW4gdmFsdWUgcmVwcmVzZW50aW5nIHdoZXRoZXIgQ291bnRhYmxlXG4gICAgICogICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbmFsaXR5IGlzIGJvdW5kIHRvIGFsbCBnaXZlbiBlbGVtZW50cy5cbiAgICAgKi9cblxuICAgIGVuYWJsZWQ6IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsZW1lbnRzID0gWyBlbGVtZW50cyBdXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaXZlRWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmluZGV4T2YoZS5lbGVtZW50KSAhPT0gLTFcbiAgICAgIH0pLmxlbmd0aCA9PT0gZWxlbWVudHMubGVuZ3RoXG4gICAgfVxuXG4gIH1cblxuICAvKipcbiAgICogRXhwb3NlIENvdW50YWJsZSBkZXBlbmRpbmcgb24gdGhlIG1vZHVsZSBzeXN0ZW0gdXNlZCBhY3Jvc3MgdGhlXG4gICAqIGFwcGxpY2F0aW9uLiAoTm9kZSAvIENvbW1vbkpTLCBBTUQsIGdsb2JhbClcbiAgICovXG5cbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gQ291bnRhYmxlXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvdW50YWJsZSB9KVxuICB9IGVsc2Uge1xuICAgIGdsb2JhbC5Db3VudGFibGUgPSBDb3VudGFibGVcbiAgfVxufSh0aGlzKSk7XG4iLCJpbXBvcnQgaW5pdENvdW50YWJsZSBmcm9tICcuLi91dGlscy9Db3VudGFibGUnO1xuaW1wb3J0IFZhbGlkYXRvciBmcm9tICcuLi91dGlscy9WYWxpZGF0b3InO1xuXG5pZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbW1lbnQtcmF0aW5nXCIpKSB7XG4gIGluaXRDb3VudGFibGUoJyNjb21tZW50LXJhdGluZycpO1xuXG4gIFZhbGlkYXRvci5pbml0KCdmb3JtI2Zvcm0tY29tbWVudC5yYXRpbmcnLCB7XG4gICAgICBjb21tZW50OiB7XG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICByYW5nZWxlbmd0aDogWzUsIDUwMF1cbiAgICAgIH0sXG4gICAgICByYXRpbmc6IHtcbiAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgIH1cbiAgfSk7XG5cbiAgLy8vIFJhdGluZyB2YWxpZGF0aW9uXG4gIC8vIEdldCBlbGVtZW50c1xuICB2YXIgcmF0aW5nX2lucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyYXRpbmdfaW5wdXRcIik7XG4gIHZhciByYXRpbmdfbnVtYmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyYXRpbmdfbnVtYmVyXCIpO1xuICB2YXIgc3RhcnNfZmlsbGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5zdGFyLWZpbGxlZFwiKTtcbiAgdmFyIHN0YXJzX2VtcHR5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5zdGFyLWVtcHR5XCIpO1xuICAvLyBSZXNldCBpbnB1dFxuICByYXRpbmdfaW5wdXQudmFsdWUgPSBudWxsO1xuICAvLyBTZXQgY2xpY2sgZXZlbnRzIHRvIGljb25zXG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc3RhclwiKS5mb3JFYWNoKGZ1bmN0aW9uKHN0YXIpIHtcbiAgICBzdGFyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgZm9ybWF0X3JhdGluZyhzdGFyLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpKTtcbiAgICB9KTtcbiAgICBzdGFyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgZm9ybWF0X3JhdGluZygpO1xuICAgIH0pO1xuICAgIHN0YXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgY2hhbmdlX3JhdGluZyhzdGFyKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdF9yYXRpbmcoc2NvcmU9bnVsbCkge1xuICAvLyBHZXQgc2NvcmUgZnJvbSBpbnB1dCBpZiBpcyBub3Qgc2V0XG4gIGlmKHNjb3JlID09IG51bGwpe1xuICAgIHNjb3JlID0gcmF0aW5nX2lucHV0LnZhbHVlO1xuICB9XG4gIC8vIFNldCBzdGFycyB2aXNpYmlsaXR5XG4gIHN0YXJzX2ZpbGxlZC5mb3JFYWNoKGZ1bmN0aW9uKHN0YXJfZmlsbGVkKSB7XG4gICAgc3Rhcl9maWxsZWQuaGlkZGVuID0gdHJ1ZTtcbiAgICBpZihzdGFyX2ZpbGxlZC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA8PSBzY29yZSkge1xuICAgICAgc3Rhcl9maWxsZWQuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgc3RhcnNfZW1wdHkuZm9yRWFjaChmdW5jdGlvbihzdGFyX2VtcHR5KSB7XG4gICAgc3Rhcl9lbXB0eS5oaWRkZW4gPSB0cnVlO1xuICAgIGlmKHN0YXJfZW1wdHkuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPiBzY29yZSkge1xuICAgICAgc3Rhcl9lbXB0eS5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICAvLyBDaGFuZ2Ugc2NvcmUgdGV4dFxuICBpZihzY29yZSAhPSBudWxsICYmIHNjb3JlICE9IFwiXCIpIHtcbiAgICByYXRpbmdfbnVtYmVyLmlubmVySFRNTCA9IHNjb3JlO1xuICB9ZWxzZXtcbiAgICByYXRpbmdfbnVtYmVyLmlubmVySFRNTCA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hhbmdlX3JhdGluZyhzdGFyKSB7XG4gIHJhdGluZ19pbnB1dC52YWx1ZSA9IHN0YXIuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG59XG4iLCJpbXBvcnQgQ291bnRhYmxlIGZyb20gJ2NvdW50YWJsZSc7XG5cbmNvbnN0IGluaXQgPSBzZWxlY3RvciA9PiB7XG4gICAgY29uc3QgJGlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgY29uc3QgbGltaXQgPSAkaW5wdXQuZGF0YXNldC5saW1pdDtcbiAgICBsZXQgbGFiZWwgPSAkaW5wdXQuZGF0YXNldC5sYWJlbDtcblxuICAgIGlmICghbGltaXQgfHwgIWxhYmVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgJGNvdW50ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgJGNvdW50ZXIuY2xhc3NMaXN0ID0gJ2JhZGdlIGJhZGdlLWluZm8gbXItMSc7XG4gICAgJGNvdW50ZXIuaW5uZXJUZXh0ID0gbGltaXQ7XG5cbiAgICBsZXQgJGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICRsYWJlbC5jbGFzc0xpc3QgPSAnc21hbGwnO1xuICAgICRsYWJlbC5pbm5lclRleHQgPSBMYW5nLmdldChsYWJlbCk7XG5cbiAgICBsZXQgJGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICRjb250YWluZXIuY2xhc3NMaXN0ID0gJ2Zsb2F0LXJpZ2h0JztcblxuICAgICRjb250YWluZXIuYXBwZW5kQ2hpbGQoJGNvdW50ZXIpO1xuICAgICRjb250YWluZXIuYXBwZW5kQ2hpbGQoJGxhYmVsKTtcblxuICAgICRpbnB1dC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKCRjb250YWluZXIsICRpbnB1dCk7XG5cbiAgICBsYWJlbCA9IGxhYmVsICE9PSAnd29yZHMnID8gJ2FsbCcgOiBsYWJlbDtcbiAgICBDb3VudGFibGUub24oJGlucHV0LCBjb3VudGVyID0+IHtcbiAgICAgICAgbGV0IGNvdW50ID0gbGltaXQgLSBjb3VudGVyW2xhYmVsXTtcbiAgICAgICAgaWYgKGNvdW50IDw9IDApIHtcbiAgICAgICAgICAgICRjb3VudGVyLmlubmVyVGV4dCA9ICcwJztcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gJGlucHV0LnZhbHVlO1xuICAgICAgICAgICAgaWYgKGxhYmVsID09PSAnYWxsJykge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBsaW1pdCAtIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY291bnQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgdGV4dC5sYXN0SW5kZXhPZignICcpKTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkaW5wdXQudmFsdWUgPSB0ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGNvdW50ZXIuaW5uZXJUZXh0ID0gY291bnQ7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGluaXQ7XG4iLCIvKlxuICAgIFZhbGlkYXRpb24uanNcblxuICAgIFZhbGlkYXRpb24gY29yZVxuXG4gICAgSnVhbiBDYXJsb3MgRXNwaW5vc2EgQ2VuaWNlcm9zXG4gICAgRWR1Y2FyVW5vIDIwMThcbiovXG5cbi8vIEV4dGVuZCB2YWxpZGF0b3JcbiQudmFsaWRhdG9yLmFkZE1ldGhvZChcbiAgICAnd2hpdGVzcGFjZXMnLFxuICAgICh2YWx1ZSwgZWxlbWVudCkgPT4ge1xuICAgICAgICByZXR1cm4gdmFsdWUuaW5kZXhPZignICcpIDwgMCAmJiB2YWx1ZSAhPSAnJztcbiAgICB9LFxuICAgIExhbmcuZ2V0KCdCbGFuayBzcGFjZXMgYXJlIG5vdCBhbGxvd2VkJylcbik7XG5cbiQudmFsaWRhdG9yLmFkZE1ldGhvZChcbiAgICAnYWxwaGFfZGFzaCcsXG4gICAgKHZhbHVlLCBlbGVtZW50KSA9PiB7XG4gICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ15bYS16QS1aMC05Xy1dKyQnKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hdGNoKHJlZ2V4KTtcbiAgICB9LFxuICAgIExhbmcuZ2V0KCdPbmx5IGxldHRlcnMsIG51bWJlcnMsIGh5cGhlbiBhbmQgdW5kZXJzY29yZSBhcmUgYWxsb3dlZCcpXG4pO1xuXG4kLnZhbGlkYXRvci5zZXREZWZhdWx0cyh7XG4gICAgaWdub3JlOiBmYWxzZSxcbiAgICBlcnJvckVsZW1lbnQ6ICdzcGFuJyxcbiAgICBlcnJvckNsYXNzOiAnaXMtaW52YWxpZCBzbWFsbCB0ZXh0LWRhbmdlcicsXG4gICAgdmFsaWRDbGFzczogJ2lzLXZhbGlkJ1xufSk7XG5cbmNvbnN0IGNmZyA9IHtcbiAgICBlcnJvclBsYWNlbWVudDoge1xuICAgICAgICBkZWZhdWx0KGVycm9yLCBlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgJChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAgICAgLmhhc0NsYXNzKCdpbnB1dC1ncm91cCcpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIC5wYXJlbnQoKVxuICAgICAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICQoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgLnBhcmVudCgpXG4gICAgICAgICAgICAgICAgICAgIC5pcygnbGFiZWwnKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgJChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAgICAgLnBhcmVudCgpXG4gICAgICAgICAgICAgICAgICAgIC5wYXJlbnQoKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHR3b0xldmVsKGVycm9yLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAkKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgLnBhcmVudCgpXG4gICAgICAgICAgICAgICAgLnBhcmVudCgpXG4gICAgICAgICAgICAgICAgLnBhcmVudCgpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChlcnJvcik7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGUoZXJyb3IsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICgkKGVsZW1lbnQpLmF0dHIoJ3R5cGUnKSA9PSAnZmlsZScpIHtcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIC5wYXJlbnQoKVxuICAgICAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAgICAgLnBhcmVudCgpXG4gICAgICAgICAgICAgICAgICAgIC5wYXJlbnQoKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAkKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5oYXNDbGFzcygnaW5wdXQtZ3JvdXAnKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAkKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wYXJlbnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnBhcmVudCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBkZWZhdWx0KGVsZW1lbnQsIGVycm9yQ2xhc3MsIHZhbGlkQ2xhc3MpIHtcbiAgICAgICAgICAgICQoZWxlbWVudClcbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3ModmFsaWRDbGFzcylcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoZXJyb3JDbGFzcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHR3b0xldmVsKGVsZW1lbnQsIGVycm9yQ2xhc3MsIHZhbGlkQ2xhc3MpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIC5wYXJlbnQoKVxuICAgICAgICAgICAgICAgICAgICAuaGFzQ2xhc3MoJ2lucHV0LWdyb3VwJylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICQoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgLnBhcmVudCgpXG4gICAgICAgICAgICAgICAgICAgIC5jaGlsZHJlbigpXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyh2YWxpZENsYXNzKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoZXJyb3JDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHZhbGlkQ2xhc3MpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKGVycm9yQ2xhc3MpO1xuICAgICAgICB9LFxuICAgICAgICBmaWxlKGVsZW1lbnQsIGVycm9yQ2xhc3MsIHZhbGlkQ2xhc3MpIHtcbiAgICAgICAgICAgICQoZWxlbWVudClcbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3ModmFsaWRDbGFzcylcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoZXJyb3JDbGFzcyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHVuaGlnaGxpZ2h0OiB7XG4gICAgICAgIGRlZmF1bHQoZWxlbWVudCwgZXJyb3JDbGFzcywgdmFsaWRDbGFzcykge1xuICAgICAgICAgICAgJChlbGVtZW50KVxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhlcnJvckNsYXNzKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh2YWxpZENsYXNzKTtcbiAgICAgICAgICAgICQoZWxlbWVudClcbiAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAuY2hpbGRyZW4oJ3NwYW4uJyArIGVycm9yQ2xhc3MpXG4gICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICB9LFxuICAgICAgICB0d29MZXZlbChlbGVtZW50LCBlcnJvckNsYXNzLCB2YWxpZENsYXNzKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgJChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAgICAgLmhhc0NsYXNzKCdpbnB1dC1ncm91cCcpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAkKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIC5wYXJlbnQoKVxuICAgICAgICAgICAgICAgICAgICAuY2hpbGRyZW4oKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoZXJyb3JDbGFzcylcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHZhbGlkQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJChlbGVtZW50KVxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhlcnJvckNsYXNzKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh2YWxpZENsYXNzKTtcbiAgICAgICAgICAgICQoZWxlbWVudClcbiAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAuY2hpbGRyZW4oJ3NwYW4uJyArIGVycm9yQ2xhc3MpXG4gICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBmaWxlKGVsZW1lbnQsIGVycm9yQ2xhc3MsIHZhbGlkQ2xhc3MpIHtcbiAgICAgICAgICAgICQoZWxlbWVudClcbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoZXJyb3JDbGFzcylcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModmFsaWRDbGFzcyk7XG4gICAgICAgICAgICAkKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgLnBhcmVudCgpXG4gICAgICAgICAgICAgICAgLmNoaWxkcmVuKCdzcGFuLicgKyBlcnJvckNsYXNzKVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW52YWxpZEhhbmRsZXI6IHtcbiAgICAgICAgZGVmYXVsdChlLCB2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHRvYXN0clsnZXJyb3InXShcbiAgICAgICAgICAgICAgICBMYW5nLmdldCgnVGhlcmUgYXJlIGVycm9ycyBpbiB0aGUgdmFsaWRhdGlvbiBvZiB0aGUgZmllbGRzJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbGxhcHNlUGFuZWwoZSwgdmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbGlkYXRvci5lcnJvckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAkKHZhbGlkYXRvci5lcnJvckxpc3RbaV0uZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgLmNsb3Nlc3QoJy5wYW5lbC1jb2xsYXBzZS5jb2xsYXBzZScpXG4gICAgICAgICAgICAgICAgICAgIC5jb2xsYXBzZSgnc2hvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBzdWJtaXRIYW5kbGVyOiB7XG4gICAgICAgIGRlZmF1bHQoJGZvcm0pIHtcbiAgICAgICAgICAgICQoJ2lucHV0W3R5cGU9XCJzdWJtaXRcIl0nKS5hdHRyKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgJGZvcm0uc3VibWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdChmb3JtX3NlbGVjdG9yLCBydWxlcywgbWVzc2FnZXMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0ICRmb3JtID0gJChmb3JtX3NlbGVjdG9yKTtcbiAgICAgICAgY29uc3QgZm9ybXNfY291bnQgPSAkZm9ybS5sZW5ndGg7XG4gICAgICAgIGlmIChmb3Jtc19jb3VudCA9PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Zvcm0gWycgKyBmb3JtX3NlbGVjdG9yICsgJ10gZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHJ1bGVzOiBydWxlcyxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyxcbiAgICAgICAgICAgIGludmFsaWRIYW5kbGVyOlxuICAgICAgICAgICAgICAgIGNmZy5pbnZhbGlkSGFuZGxlcltvcHRpb25zWydpbnZhbGlkSGFuZGxlciddXSB8fFxuICAgICAgICAgICAgICAgIGNmZy5pbnZhbGlkSGFuZGxlclsnZGVmYXVsdCddLFxuICAgICAgICAgICAgZXJyb3JQbGFjZW1lbnQ6XG4gICAgICAgICAgICAgICAgY2ZnLmVycm9yUGxhY2VtZW50W29wdGlvbnNbJ2Vycm9yUGxhY2VtZW50J11dIHx8XG4gICAgICAgICAgICAgICAgY2ZnLmVycm9yUGxhY2VtZW50WydkZWZhdWx0J10sXG4gICAgICAgICAgICBoaWdobGlnaHQ6XG4gICAgICAgICAgICAgICAgY2ZnLmhpZ2hsaWdodFtvcHRpb25zWydoaWdobGlnaHQnXV0gfHwgY2ZnLmhpZ2hsaWdodFsnZGVmYXVsdCddLFxuICAgICAgICAgICAgdW5oaWdobGlnaHQ6XG4gICAgICAgICAgICAgICAgY2ZnLnVuaGlnaGxpZ2h0W29wdGlvbnNbJ3VuaGlnaGxpZ2h0J11dIHx8XG4gICAgICAgICAgICAgICAgY2ZnLnVuaGlnaGxpZ2h0WydkZWZhdWx0J10sXG4gICAgICAgICAgICBzdWJtaXRIYW5kbGVyOlxuICAgICAgICAgICAgICAgIG9wdGlvbnNbJ3N1Ym1pdEhhbmRsZXInXSB8fCBjZmcuc3VibWl0SGFuZGxlclsnZGVmYXVsdCddXG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICRmb3JtLmVhY2goaSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHIgPSAkKCRmb3JtW2ldKS52YWxpZGF0ZShjb25maWcpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1zX2NvdW50ID4gMSA/IHJlc3VsdHMgOiByZXN1bHRzLnNoaWZ0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9